# -*- coding: utf-8 -*-
"""ClusteringPaleta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q5N0JshzgKgXB_sIR6qnrMJHKwfPkKI3
"""

# @title Celda 1: Configuración del Entorno y Librerías

# Instalar librerías necesarias
# Usaremos sklearn.cluster.KMeans, numpy, PIL (Pillow), matplotlib
!pip install scikit-learn numpy Pillow matplotlib

import numpy as np
from PIL import Image
from sklearn.cluster import KMeans
import os
import glob
import json
import random
import sys
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle # Para dibujar swatches de color
import matplotlib as mpl # Para paletas de colores de matplotlib

print("Librerías instaladas y cargadas.")

# @title Celda 2: Preparación del Dataset y Definición de Rutas

# --- CONFIGURACIÓN DE RUTAS ---
# Ajusta esta ruta a donde se encuentre tu carpeta "Agrupados" en Google Drive.
# Por ejemplo, si tienes "Agrupados" en la raíz de tu Drive, sería:
DATASET_BASE_PATH = "C:/Users/59174/Desktop/Agrupados"
# Si lo subiste directamente a Colab y descomprimiste, podría ser:
# DATASET_BASE_PATH = "/content/Agrupados"

# Asegurarse de que la carpeta exista
if not os.path.exists(DATASET_BASE_PATH):
    raise FileNotFoundError(f"La carpeta del dataset no se encontró en: {DATASET_BASE_PATH}\n"
                            "Por favor, verifica la ruta o asegúrate de que el dataset esté subido/montado.")
else:
    print(f"Carpeta del dataset verificada: {DATASET_BASE_PATH}")

# Ruta de salida para las paletas de colores (se guardará en el entorno de Colab por defecto)
CLASS_PALETTES_FILE = "C:/Users/59174/Desktop/lighting_class_palettes.json"

print(f"El archivo de paletas se guardará en: {CLASS_PALETTES_FILE}")
print("Rutas configuradas. Listo para definir las funciones de clustering.")

# @title Celda 3: Definición de Funciones de Clustering y Filtrado

# --- CONFIGURACIÓN DE PARÁMETROS DE CLUSTERING ---
NUM_CLASS_COLORS = 8 # Número de colores dominantes a extraer para CADA CLASE
MAX_IMAGES_PER_CLASS_FOR_COLOR_EXTRACTION = 1000 # Muestreo por clase

# Umbrales para la exclusión de grises/blancos/negros (en 0-255)
GRAY_COLOR_THRESHOLD = 15
MIN_BRIGHTNESS_THRESHOLD = 25
MAX_BRIGHTNESS_THRESHOLD = 230

# --- Funciones de Utilidad ---
def get_class_folders(base_path):
    """Obtiene los nombres de las subcarpetas (clases de iluminación)."""
    # **NOTA:** Corregí un pequeño error tipográfico si era 'for d d in'
    class_folders = [d for d in os.listdir(base_path) if os.path.isdir(os.path.join(base_path, d))]
    print(f"Clases de iluminación encontradas: {class_folders}")
    return class_folders

def get_image_luminosity(image_path):
    """Calcula la luminosidad promedio de una imagen."""
    try:
        img = Image.open(image_path)
        img = img.convert("L")
        img_array = np.array(img)
        return np.mean(img_array) / 255.0
    except Exception as e:
        print(f"Error al calcular luminosidad de {image_path}: {e}", file=sys.stderr)
        return 0.5

def extract_class_dominant_colors(class_folder_path, num_colors, max_images_sample):
    """
    Extrae colores representativos para una clase de iluminación
    aplicando K-means a una muestra de sus imágenes,
    excluyendo grises, blancos y negros extremos de forma vectorizada.
    """
    all_filtered_pixels = []
    class_luminosities = []
    image_paths = [os.path.join(class_folder_path, f) for f in os.listdir(class_folder_path)
                   if f.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif'))]

    if len(image_paths) > max_images_sample:
        image_paths = random.sample(image_paths, max_images_sample)

    print(f"  Procesando {len(image_paths)} imágenes para extraer colores de '{os.path.basename(class_folder_path)}'")

    for i, img_path in enumerate(image_paths):
        if (i + 1) % 100 == 0:
            print(f"    Procesando imagen {i+1}/{len(image_paths)}...")
        try:
            img = Image.open(img_path)
            img = img.convert("RGB")
            img_array = np.array(img, dtype=np.int16)

            pixels = img_array.reshape(-1, 3)

            max_diff = np.max(pixels, axis=1) - np.min(pixels, axis=1)
            brightness = np.mean(pixels, axis=1)

            is_gray = max_diff < GRAY_COLOR_THRESHOLD
            is_too_dark = brightness < MIN_BRIGHTNESS_THRESHOLD
            is_too_bright = brightness > MAX_BRIGHTNESS_THRESHOLD

            mask_keep = ~(is_gray | is_too_dark | is_too_bright)

            current_filtered_pixels = pixels[mask_keep]

            if current_filtered_pixels.size > 0:
                all_filtered_pixels.append(current_filtered_pixels)

            lum = get_image_luminosity(img_path)
            if lum is not None:
                class_luminosities.append(lum)

        except Exception as e:
            print(f"    Error al cargar/procesar {img_path}: {e}", file=sys.stderr)
            continue

    if not all_filtered_pixels:
        print(f"  No se encontraron píxeles de color válidos para la clase '{os.path.basename(class_folder_path)}' después del filtrado. Retornando paleta vacía y luminosidad por defecto.", file=sys.stderr)
        return [], 0.5

    pixels_for_kmeans = np.vstack(all_filtered_pixels)

    if pixels_for_kmeans.shape[0] > 1000000:
        sample_size = min(1000000, pixels_for_kmeans.shape[0])
        pixels_for_kmeans = pixels_for_kmeans[np.random.choice(pixels_for_kmeans.shape[0], sample_size, replace=False)]

    if pixels_for_kmeans.shape[0] < num_colors:
        print(f"  Advertencia: Pocos píxeles ({pixels_for_kmeans.shape[0]}) para {num_colors} clusters en '{os.path.basename(class_folder_path)}'. Reduciendo el número de clusters.", file=sys.stderr)
        actual_num_colors = pixels_for_kmeans.shape[0] if pixels_for_kmeans.shape[0] > 0 else 1
    else:
        actual_num_colors = num_colors

    if actual_num_colors == 0:
        return [], np.mean(class_luminosities) if class_luminosities else 0.5


    kmeans = KMeans(n_clusters=actual_num_colors, random_state=42, n_init='auto')
    kmeans.fit(pixels_for_kmeans)

    return kmeans.cluster_centers_.tolist(), np.mean(class_luminosities) if class_luminosities else 0.5

def generate_class_palettes(base_path, num_colors_per_class, max_images_sample):
    """
    Genera y guarda las paletas de colores representativas y la luminosidad
    promedio para cada clase de iluminación.
    """
    class_folders = get_class_folders(base_path)
    all_class_data = {}

    for class_name in class_folders:
        class_path = os.path.join(base_path, class_name)
        print(f"\nExtrayendo colores y luminosidad para la clase: {class_name}")

        dominant_colors, avg_lum = extract_class_dominant_colors(class_path, num_colors_per_class, max_images_sample)

        all_class_data[class_name] = {
            "colors": dominant_colors,
            "avg_luminosity": avg_lum
        }

    with open(CLASS_PALETTES_FILE, 'w') as f:
        json.dump(all_class_data, f, indent=4)

    print(f"\nPaletas de colores y luminosidad por clase guardadas en '{CLASS_PALETTES_FILE}'")
    return all_class_data

# @title Celda 4: Visualización del K-Means: Muestras de Imágenes y Proceso de Clustering

# --- PARÁMETROS PARA LA VISUALIZACIÓN ---
CLASS_TO_VISUALIZE = "grupo_2"
NUM_SAMPLE_IMAGES_TO_SHOW = 10
SAMPLE_IMAGE_FOR_CLUSTERING_VISUALIZATION_INDEX = 0

print(f"Preparando visualización para la clase: '{CLASS_TO_VISUALIZE}'")

# Encuentra la ruta completa a la carpeta de la clase
selected_class_path = os.path.join(DATASET_BASE_PATH, CLASS_TO_VISUALIZE)
if not os.path.exists(selected_class_path):
    raise FileNotFoundError(f"La carpeta '{CLASS_TO_VISUALIZE}' no se encontró en: {DATASET_BASE_PATH}")

# Obtén una lista de rutas de todas las imágenes de esa clase
all_image_files_in_class = [f for f in os.listdir(selected_class_path)
                            if f.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif'))]

if not all_image_files_in_class:
    raise ValueError(f"No se encontraron imágenes en la carpeta: {selected_class_path}")

# Seleccionar imágenes al azar para mostrar
random.shuffle(all_image_files_in_class)
sample_image_paths_for_display = all_image_files_in_class[:NUM_SAMPLE_IMAGES_TO_SHOW]

# --- 1. MOSTRAR IMÁGENES DE MUESTRA DEL GRUPO ---
print(f"\n--- 10 Imágenes Aleatorias de la Clase '{CLASS_TO_VISUALIZE}' ---")
plt.figure(figsize=(15, 5))
for i, img_filename in enumerate(sample_image_paths_for_display):
    img_path = os.path.join(selected_class_path, img_filename)
    try:
        img = Image.open(img_path)
        plt.subplot(1, NUM_SAMPLE_IMAGES_TO_SHOW, i + 1)
        plt.imshow(img)
        plt.title(f"Img {i+1}")
        plt.axis('off')
    except Exception as e:
        print(f"Error al cargar imagen {img_filename} para mostrar: {e}", file=sys.stderr)
        plt.subplot(1, NUM_SAMPLE_IMAGES_TO_SHOW, i + 1)
        plt.text(0.5, 0.5, "Error", ha='center', va='center', fontsize=12)
        plt.axis('off')
plt.tight_layout()
plt.show()

# --- 2. VISUALIZAR EL PROCESO DE CLUSTERING (PIXEL A PÍXEL) ---
print(f"\n--- 2. Visualización del Proceso de K-Means (Pixel a Píxel) ---")

# Selecciona la imagen específica para la visualización del clustering (de las 10 aleatorias)
if SAMPLE_IMAGE_FOR_CLUSTERING_VISUALIZATION_INDEX >= len(sample_image_paths_for_display):
    SAMPLE_IMAGE_FOR_CLUSTERING_VISUALIZATION_INDEX = 0
    print(f"Advertencia: Índice de imagen para clustering fuera de rango. Usando la primera imagen de la muestra.")

example_image_path_for_clustering = os.path.join(selected_class_path,
                                                 sample_image_paths_for_display[SAMPLE_IMAGE_FOR_CLUSTERING_VISUALIZATION_INDEX])

print(f"Imagen seleccionada para visualización del clustering: {example_image_path_for_clustering}")

try:
    img = Image.open(example_image_path_for_clustering)
    img_rgb = img.convert("RGB")
    img_array_original = np.array(img_rgb)

    max_pixels_for_plot = 50000

    if img_array_original.shape[0] * img_array_original.shape[1] > max_pixels_for_plot:
        factor = np.sqrt((img_array_original.shape[0] * img_array_original.shape[1]) / max_pixels_for_plot)
        new_height = int(img_array_original.shape[0] / factor)
        new_width = int(img_array_original.shape[1] / factor)
        img_rgb_small = img_rgb.resize((new_width, new_height), Image.Resampling.LANCZOS)
        img_array_plot = np.array(img_rgb_small, dtype=np.int16)
        print(f"  Imagen redimensionada para visualización del clustering a {new_width}x{new_height} píxeles.")
    else:
        img_array_plot = np.array(img_rgb, dtype=np.int16)

    pixels_for_plot = img_array_plot.reshape(-1, 3)

    # Filtrar píxeles de la imagen de ejemplo para la visualización
    filtered_pixels_plot = []
    for pixel in pixels_for_plot:
        r, g, b = pixel
        max_diff = max(abs(r - g), abs(r - b), abs(g - b))
        brightness = (int(r) + int(g) + int(b)) / 3
        if not (max_diff < GRAY_COLOR_THRESHOLD or \
                brightness < MIN_BRIGHTNESS_THRESHOLD or \
                brightness > MAX_BRIGHTNESS_THRESHOLD):
            filtered_pixels_plot.append(pixel)

    pixels_for_plot_filtered = np.array(filtered_pixels_plot)
    if pixels_for_plot_filtered.size == 0:
        print("  No hay píxeles de color válidos en la imagen seleccionada para la visualización después del filtrado. Selecciona otra imagen.")
        raise ValueError("No hay píxeles filtrados para la visualización.")

    print(f"  Píxeles filtrados para visualización del clustering: {pixels_for_plot_filtered.shape[0]}")

    X_plot_normalized = pixels_for_plot_filtered / 255.0

    # --- FUNCIONES DE VISUALIZACIÓN ADAPTADAS DE TU GUÍA (para 3D RGB) ---
    def plot_pixels_3d(X_pixels_norm, y_labels=None, title="Píxeles de Imagen en Espacio RGB", s=1, cmap="viridis"):
        """Grafica píxeles en el espacio RGB 3D."""
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        # Muestreo para que el gráfico no sea demasiado denso
        sample_indices = np.random.choice(len(X_pixels_norm), min(len(X_pixels_norm), 15000), replace=False)
        X_sample = X_pixels_norm[sample_indices]
        y_sample = y_labels[sample_indices] if y_labels is not None else None

        ax.scatter(X_sample[:, 0], X_sample[:, 1], X_sample[:, 2], c=y_sample, s=s, cmap=cmap)

        ax.set_xlabel("Rojo (R)"); ax.set_ylabel("Verde (G)"); ax.set_zlabel("Azul (B)")
        ax.set_title(title)
        ax.set_xlim(0, 1); ax.set_ylim(0, 1); ax.set_zlim(0, 1)
        plt.show()

    def plot_centroids_3d(centroids, circle_color='w', cross_color='k', s_marker_circle=200, s_marker_cross=50):
        """Grafica centroides en el espacio RGB 3D."""
        fig = plt.gcf() # Obtener la figura actual
        ax = fig.gca(projection='3d') # Obtener los ejes 3D actuales

        ax.scatter(centroids[:, 0], centroids[:, 1], centroids[:, 2],
                   marker='o', s=s_marker_circle, linewidths=8, color=circle_color, zorder=10, alpha=0.9)
        ax.scatter(centroids[:, 0], centroids[:, 1], centroids[:, 2],
                   marker='x', s=s_marker_cross, linewidths=10, color=cross_color, zorder=11, alpha=1)

    # --- Ejecución del K-Means paso a paso para visualización ---
    print("\nVisualizando el proceso de K-Means (iteraciones en espacio RGB 3D)...")

    kmeans_iter1 = KMeans(n_clusters=NUM_CLASS_COLORS, init="k-means++", n_init=1,
                         algorithm="lloyd", max_iter=1, random_state=42)
    kmeans_iter2 = KMeans(n_clusters=NUM_CLASS_COLORS, init="k-means++", n_init=1,
                         algorithm="lloyd", max_iter=2, random_state=42)
    kmeans_final = KMeans(n_clusters=NUM_CLASS_COLORS, init="k-means++", n_init=1,
                         algorithm="lloyd", max_iter=10, random_state=42) # Iteraciones para convergencia

    # Ejecutar cada paso y graficar
    print("  Paso 1: Inicialización de centroides y primera asignación...")
    kmeans_iter1.fit(X_plot_normalized)
    y_pred_iter1 = kmeans_iter1.predict(X_plot_normalized)
    plot_pixels_3d(X_plot_normalized, y_pred_iter1, title="K-Means: Asignación tras 1 Iteración (Centros: Azar)", cmap="viridis")

    print("  Paso 2: Recálculo de centroides y segunda asignación...")
    kmeans_iter2.fit(X_plot_normalized)
    y_pred_iter2 = kmeans_iter2.predict(X_plot_normalized)
    plot_pixels_3d(X_plot_normalized, y_pred_iter2, title="K-Means: Asignación tras 2 Iteraciones", cmap="viridis")

    print("  Paso Final: Convergencia de K-Means...")
    kmeans_final.fit(X_plot_normalized)
    y_pred_final = kmeans_final.predict(X_plot_normalized)
    plot_pixels_3d(X_plot_normalized, y_pred_final, title="K-Means: Convergencia Final", cmap="viridis")

    print(f"\nCentroides de color finales para la imagen de ejemplo (RGB 0-255):")
    final_colors_255 = (kmeans_final.cluster_centers_ * 255).astype(int)
    for i, color in enumerate(final_colors_255):
        print(f"  Cluster {i+1}: RGB({color[0]}, {color[1]}, {color[2]})")

    plt.figure(figsize=(NUM_CLASS_COLORS * 1.5, 2))
    for i, color in enumerate(kmeans_final.cluster_centers_):
        rect = Rectangle((i, 0), 1, 1, facecolor=color)
        plt.gca().add_patch(rect)
    plt.xlim(0, NUM_CLASS_COLORS)
    plt.ylim(0, 1)
    plt.xticks([])
    plt.yticks([])
    plt.title("Paleta de Colores Extraída (Imagenes de Ejemplo)")
    plt.show()


except FileNotFoundError as e:
    print(f"Error: {e}")
    print("Asegúrate de que la ruta de la imagen o la clase sean correctas en DATASET_BASE_PATH y CLASS_TO_VISUALIZE.")
except ValueError as e:
    print(f"Error de valor: {e}")
    print("Puede que la imagen seleccionada no tenga píxeles de color después del filtrado o que no se pueda procesar. Intenta con otra imagen o ajusta los umbrales de filtrado.")
except Exception as e:
    print(f"Ocurrió un error inesperado durante la visualización: {e}", file=sys.stderr)

# @title Celda 5: Ejecución del Clustering Global y Visualización de Paletas Finales por Clase

print("\n--- INICIANDO CLUSTERING GLOBAL DEL DATASET ---")
print("Este proceso puede tardar un tiempo dependiendo del tamaño del dataset y los parámetros.")

# Ejecutar la función generate_class_palettes
generated_palettes_data = generate_class_palettes(
    DATASET_BASE_PATH, NUM_CLASS_COLORS, MAX_IMAGES_PER_CLASS_FOR_COLOR_EXTRACTION
)

print(f"\nClustering global completado. Paletas guardadas en: {CLASS_PALETTES_FILE}")

# --- VISUALIZACIÓN DE LAS PALETAS DE COLORES GLOBALES POR CLASE ---
print("\n--- Resumen de Paletas de Colores Globales por Clase ---")

fig, axes = plt.subplots(len(generated_palettes_data), 1, figsize=(12, len(generated_palettes_data) * 2))
if len(generated_palettes_data) == 1: # Manejo si solo hay una clase
    axes = [axes]
elif len(generated_palettes_data) == 0:
    print("No se generaron paletas para visualizar.")
    plt.close(fig) # Close empty figure
    # Opcional: descargar el archivo si se generó
    # if os.path.exists(CLASS_PALETTES_FILE):
    #     from google.colab import files
    #     files.download(CLASS_PALETTES_FILE)
    sys.exit("No se generaron paletas. Verifica tu dataset y configuración.")


for ax, (class_name, data) in zip(axes, generated_palettes_data.items()):
    colors = np.array(data["colors"]) / 255.0 # Normalizar a 0-1 para matplotlib
    avg_luminosity = data["avg_luminosity"]

    if len(colors) == 0:
        ax.set_title(f"Clase: {class_name} (No colors extracted)", fontsize=12)
        ax.set_visible(False) # Ocultar subplots vacíos
        continue

    for i, color in enumerate(colors):
        rect = Rectangle((i, 0), 1, 1, facecolor=color)
        ax.add_patch(rect)

    ax.set_xlim(0, len(colors))
    ax.set_ylim(0, 1)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal')
    ax.set_title(f"Clase: {class_name} | Luminosidad Promedio: {avg_luminosity:.2f}", fontsize=14)

plt.tight_layout()
plt.show()

# Opcional: Descargar el archivo JSON de paletas
# from google.colab import files
# files.download(CLASS_PALETTES_FILE)
# print(f"\nArchivo {CLASS_PALETTES_FILE} descargado a tu máquina local.")